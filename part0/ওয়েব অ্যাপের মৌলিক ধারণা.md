ওয়েব অ্যাপ্লিকেশনগুলির মৌলিক ধারণা

প্রোগ্রামিং শুরু করার আগে, আমরা ওয়েব ডেভেলপমেন্টের কিছু মৌলিক ধারণা পর্যালোচনা করব। এর জন্য, আমরা একটি উদাহরণ অ্যাপ্লিকেশন দেখতে যাচ্ছি, যা এই লিঙ্কে পাওয়া যাবে: https://studies.cs.helsinki.fi/exampleapp

এই অ্যাপ্লিকেশনটি শুধুমাত্র কোর্সের কিছু মৌলিক ধারণা প্রদর্শনের জন্য তৈরি করা হয়েছে এবং এটি আধুনিক ওয়েব অ্যাপ্লিকেশন কিভাবে তৈরি করা উচিত তার কোনো উদাহরণ নয়। বরং, এটি ওয়েব ডেভেলপমেন্টের কিছু পুরনো প্রযুক্তি প্রদর্শন করে, যেগুলি এখনকার দিনেও হয়তো খারাপ প্র্যাকটিস হিসেবে গণ্য হতে পারে।

কোডের মান আধুনিক ও সেরা প্র্যাকটিস অনুসরণ করবে, প্রথম পর্ব থেকে।

উদাহরণ অ্যাপ্লিকেশনটি ব্রাউজারে খুলুন

ব্রাউজারে অ্যাপ্লিকেশনটি খুলুন। কখনও কখনও এটি লোড হতে একটু সময় নিতে পারে।

এই কোর্সের উপকরণ গুলি Chrome ব্রাউজারের জন্য তৈরি এবং অভিযোজিত।

ওয়েব ডেভেলপমেন্টের প্রথম নিয়ম

সবসময় আপনার ব্রাউজারের ডেভেলপার কনসোল খুলে রাখুন।

macOS-এ কনসোল খুলতে, একসাথে fn-F12 অথবা option-cmd-i চাপুন।

Windows/Linux-এ কনসোল খুলতে, একসাথে Fn-F12 অথবা ctrl-shift-i চাপুন।

আপনি কনটেক্সট মেনু থেকেও কনসোল খুলতে পারবেন।

মনে রাখবেন, ওয়েব অ্যাপ্লিকেশন ডেভেলপ করার সময় ডেভেলপার কনসোল সবসময় খোলা রাখবেন।

ডেভেলপার কনসোলের চিত্র

ডেভেলপার টুলস খোলার পর, এটি সাধারণত এইরকম দেখতে হবে:

(এখানে একটি কনসোল স্ক্রীনশট থাকবে)

কনসোলের নিচে কিছু ট্যাব থাকে। নিচের কয়েকটি সেটিংস আপনার কাজে আসবে:

Network Tab: এটি চেক করা থাকলে আপনি ওয়েব পৃষ্ঠার সমস্ত নেটওয়ার্ক রিকোয়েস্ট দেখতে পাবেন।

Disable cache: এই অপশনটি চেক করলে ক্যাশে ডিসেবল হয়ে যাবে, অর্থাৎ ওয়েব পৃষ্ঠার নতুন ভার্সনটি সবসময় লোড হবে।

Preserve log: এই অপশনটি আপনার অ্যাপ্লিকেশনটি রিলোড করার সময় কনসোলের লগ সেভ করবে।

Hide extension URLs: এই অপশনটি চেক করলে ব্রাউজারের এক্সটেনশনের রিকোয়েস্টগুলো হাইড হয়ে যাবে।

সবচেয়ে গুরুত্বপূর্ণ ট্যাব

সবচেয়ে গুরুত্বপূর্ণ ট্যাব হলো Console Tab। তবে, এই প্রবর্তন পর্বে আমরা বেশ কিছু সময় Network Tab ব্যবহার করব।

এই টুলগুলি এবং কনসোল ব্যবহার করার অভ্যাস আপনি যত বেশি করবেন, তত বেশি সহজ হবে ওয়েব ডেভেলপমেন্ট। ডেভেলপার কনসোলের সাহায্যে আপনি আপনার অ্যাপ্লিকেশন কীভাবে কাজ করছে, কোথায় সমস্যা হতে পারে, এবং কত দ্রুত আপনার পৃষ্ঠাটি লোড হচ্ছে তা দেখতে পারবেন।







HTTP GET

সার্ভার এবং ওয়েব ব্রাউজার একে অপরের সাথে HTTP প্রোটোকল ব্যবহার করে যোগাযোগ করে। Network Tab ব্রাউজার এবং সার্ভারের মধ্যে এই যোগাযোগ কিভাবে হচ্ছে তা প্রদর্শন করে।

যখন আপনি পেজটি রিলোড করবেন (পেজ রিফ্রেশ করতে, উইন্ডোজে Fn-F5 কী চাপুন, অথবা macOS-এ command-R চাপুন, অথবা আপনার ব্রাউজারের ↻ সিম্বল ক্লিক করুন), কনসোল আপনাকে দুটি ঘটনা দেখাবে:

ব্রাউজার সার্ভার থেকে studies.cs.helsinki.fi/exampleapp পেজের কনটেন্ট পেয়েছে।

ব্রাউজার kuva.png ইমেজটি ডাউনলোড করেছে।

(এখানে একটি স্ক্রীনশট থাকবে যা কনসোলে এই দুটি ঘটনাকে প্রদর্শন করছে)

যদি আপনার স্ক্রীন ছোট হয়, তাহলে কনসোল উইন্ডোটা একটু বড় করতে হতে পারে।

প্রথম ঘটনাটির উপর ক্লিক করলে আরও বিস্তারিত তথ্য দেখা যাবে:

একটি একক ঘটনার বিস্তারিত দেখানো

উপরের অংশে, General শিরোনামে দেখা যায় যে ব্রাউজার https://studies.cs.helsinki.fi/exampleapp
 ঠিকানাটি GET পদ্ধতি ব্যবহার করে অনুরোধ করেছে, এবং সার্ভারের প্রতিক্রিয়া সফল হয়েছে কারণ স্ট্যাটাস কোড ২০০ (OK) পাওয়া গেছে।

অনুরোধ এবং সার্ভারের প্রতিক্রিয়া দুটি বিভিন্ন হেডার ধারণ করে:

প্রতিক্রিয়া হেডারের স্ক্রীনশট

Response headers উপরের দিকে দেখায় যেমন:

প্রতিক্রিয়ার আকার (বাইটে)

প্রতিক্রিয়ার সঠিক সময়

Content-Type হেডারটি আমাদের বলে যে প্রতিক্রিয়া একটি utf-8 ফরম্যাটের টেক্সট ফাইল এবং এটি HTML দিয়ে ফরম্যাট করা হয়েছে। এর মাধ্যমে ব্রাউজার জানে যে প্রতিক্রিয়া একটি সাধারণ HTML পৃষ্ঠা এবং সেটি ওয়েব পেজ হিসেবে ব্রাউজারে রেন্ডার করবে।

Response Tab-এ আপনি প্রতিক্রিয়া ডেটা দেখতে পারবেন, যা একটি সাধারণ HTML পৃষ্ঠা। Body সেকশনে পৃষ্ঠার কাঠামো নির্ধারণ করা হয়, যা স্ক্রীনে রেন্ডার হয়:

(এখানে একটি স্ক্রীনশট থাকবে যা রেসপন্স ট্যাবের বিস্তারিত দেখাবে)

পৃষ্ঠাটির মধ্যে একটি div উপাদান রয়েছে, যা একটি শিরোনাম, একটি লিঙ্ক (notes পৃষ্ঠার জন্য), একটি img ট্যাগ এবং তৈরি হওয়া নোটের সংখ্যা প্রদর্শন করে।

দ্বিতীয় HTTP GET অনুরোধ

কারণ এখানে একটি img ট্যাগ রয়েছে, ব্রাউজার দ্বিতীয় HTTP অনুরোধ পাঠায় kuva.png ইমেজটি সার্ভার থেকে ফেচ করার জন্য। অনুরোধের বিস্তারিত:

দ্বিতীয় ঘটনার বিস্তারিত

এই অনুরোধটি https://studies.cs.helsinki.fi/exampleapp/kuva.png
 ঠিকানায় করা হয়েছিল এবং এটি ছিল একটি HTTP GET অনুরোধ। সার্ভারের প্রতিক্রিয়ার হেডারগুলি বলে দেয় যে প্রতিক্রিয়ার আকার 89350 বাইট এবং এর Content-Type হলো image/png, অর্থাৎ এটি একটি PNG ইমেজ। ব্রাউজার এই তথ্য ব্যবহার করে সঠিকভাবে ইমেজটি স্ক্রীনে রেন্ডার করে।

সিকোয়েন্স ডায়াগ্রাম

এই ওয়েব পৃষ্ঠাটি খোলার ফলে যে ঘটনার ধারাবাহিকতা তৈরি হয়, তা নিম্নলিখিত সিকোয়েন্স ডায়াগ্রাম হিসেবে চিত্রিত হতে পারে:

(এখানে সিকোয়েন্স ডায়াগ্রামের স্ক্রীনশট থাকবে)

ডায়াগ্রামটি ব্রাউজার এবং সার্ভারের মধ্যে সময় অনুযায়ী কিভাবে যোগাযোগ হচ্ছে তা প্রদর্শন করে। ডায়াগ্রামে সময় উপরের থেকে নিচে প্রবাহিত হয়, এবং এটি ব্রাউজারের প্রথম অনুরোধের সাথে শুরু হয়, যা সার্ভারের প্রতিক্রিয়া দ্বারা অনুসৃত হয়।

প্রথমে, ব্রাউজার HTTP GET অনুরোধ পাঠায় সার্ভারে, যাতে পৃষ্ঠাটির HTML কোড পাওয়া যায়। HTML এর মধ্যে থাকা img ট্যাগটি ব্রাউজারকে kuva.png ইমেজটি ফেচ করতে বলছে। এরপর ব্রাউজার HTML পৃষ্ঠা এবং ইমেজটি স্ক্রীনে রেন্ডার করে।

এটি লক্ষ্য করা কঠিন হলেও, HTML পৃষ্ঠাটি ইমেজটি সার্ভার থেকে ফেচ হওয়ার আগেই রেন্ডার শুরু হয়ে যায়।

এইভাবে HTTP GET অনুরোধের মাধ্যমে ওয়েব পৃষ্ঠাটি রেন্ডার হয়, এবং ব্রাউজার ও সার্ভারের মধ্যে তথ্য আদান-প্রদান ঘটে।


প্রথাগত (Traditional) ওয়েব অ্যাপ্লিকেশন

উদাহরণ অ্যাপ্লিকেশনটির হোমপেজটি একটি প্রথাগত ওয়েব অ্যাপ্লিকেশন এর মতো কাজ করে। যখন আপনি এই পৃষ্ঠায় প্রবেশ করেন, তখন ব্রাউজার সার্ভার থেকে HTML ডকুমেন্টটি ফেচ করে, যা পৃষ্ঠাটির গঠন (structure) এবং লেখাসমূহ (textual content) ধারণ করে।

সার্ভার কিভাবে HTML ডকুমেন্ট তৈরি করে?

সার্ভার এই ডকুমেন্টটি নিচের দুইভাবে তৈরি করতে পারে:

স্ট্যাটিক ফাইল (Static file): এটি সার্ভারের একটি নির্দিষ্ট ডিরেক্টরিতে সংরক্ষিত একটি সাধারণ টেক্সট ফাইল হতে পারে।

ডাইনামিক HTML: সার্ভার অ্যাপ্লিকেশনের কোড অনুযায়ী HTML ডকুমেন্টটি তৈরি করতে পারে। এই ক্ষেত্রে, সার্ভার হয়তো কোনো ডেটাবেস থেকে তথ্য নিয়ে HTML গঠন করে।

📌 উদাহরণ অ্যাপ্লিকেশনটির HTML ডাইনামিকভাবে তৈরি হয়েছে, কারণ এতে তৈরি হওয়া নোটের সংখ্যা দেখানো হচ্ছে।

হোমপেজের HTML কিভাবে তৈরি হয়?

সার্ভারে নিচের JavaScript কোড ব্যবহার করে হোমপেজের HTML তৈরি করা হয়:

const getFrontPageHtml = noteCount => {
  return `
    <!DOCTYPE html>
    <html>
      <head>
      </head>
      <body>
        <div class='container'>
          <h1>Full stack example app</h1>
          <p>number of notes created ${noteCount}</p>
          <a href='/notes'>notes</a>
          <img src='kuva.png' width='200' />
        </div>
      </body>
    </html>
  `
}

app.get('/', (req, res) => {
  const page = getFrontPageHtml(notes.length)
  res.send(page)
})


📌 এই কোডটি এখন বোঝা না গেলেও সমস্যা নেই। এটি আমরা পরবর্তীতে বিস্তারিতভাবে বুঝব।

কোড বিশ্লেষণ (সহজ ভাষায়):

getFrontPageHtml(noteCount) একটি function, যা নোটের সংখ্যা নিয়ে একটি HTML টেমপ্লেট রিটার্ন করে।

${noteCount} হলো template string-এর ভিতরে variable বসানোর একটি উপায়। এখানে এটি নোটের সংখ্যা দেখানোর জন্য ব্যবহৃত হয়েছে।

app.get('/', ...) অংশটি বলছে: যখন কেউ হোমপেজ (/) এ আসবে, তখন getFrontPageHtml() ফাংশন চালিয়ে HTML তৈরি করে পাঠিয়ে দাও।

📝 এইভাবে, HTML পৃষ্ঠাটি প্রতি রিকোয়েস্টে ডাইনামিকভাবে তৈরি হয়।

টেমপ্লেট স্ট্রিং কী?

টেমপ্লেট স্ট্রিং হলো এমন একটি স্ট্রিং যেখানে আপনি পরিবর্তনশীল (variable) গুলোকে ${...} এর মাধ্যমে বসাতে পারেন। এতে করে আপনি সহজেই ডাইনামিক কনটেন্ট HTML এর মধ্যে বসাতে পারেন।

পুরানো স্টাইল কোডিং

এইভাবে সরাসরি কোডের মাঝে HTML লেখা আজকাল তেমন প্রচলিত নয়। কিন্তু পুরোনো দিনের PHP প্রোগ্রামারদের জন্য এটি ছিল একেবারে স্বাভাবিক কাজ।

প্রথাগত ওয়েব অ্যাপ্লিকেশনে ব্রাউজার “বোকার মতো”

প্রথাগত ওয়েব অ্যাপ্লিকেশনের বৈশিষ্ট্য:

ব্রাউজার শুধুমাত্র HTML ডেটা রিসিভ করে এবং সেটা স্ক্রিনে রেন্ডার করে।

সমস্ত অ্যাপ্লিকেশন লজিক সার্ভারে থাকে।

ক্লায়েন্ট সাইডে (মানে ব্রাউজারে) কোনো জটিল কাজ হয় না।

✅ উদাহরণস্বরূপ, প্রথাগত সার্ভার তৈরি করা যেতে পারে:

Java Spring

Python Flask

Ruby on Rails

অথবা বর্তমান কোর্সে ব্যবহৃত Node.js ও Express

এই কোর্সে কী ব্যবহার করা হবে?

এই কোর্সে Node.js এবং Express লাইব্রেরি ব্যবহার করে ওয়েব সার্ভার তৈরি করা শেখানো হবে।

ব্রাউজারে অ্যাপ্লিকেশন লজিক চালানো (Running Application Logic in the Browser)
🔧 প্রস্তুতি

ডেভেলপার কনসোল খুলে রাখুন।

কনসোল খালি করতে:

🚫 আইকনে ক্লিক করুন

অথবা টাইপ করুন: clear()

এখন যখন আপনি notes পেজে যান, তখন ব্রাউজার ৪টি HTTP রিকোয়েস্ট পাঠায়:

(এখানে একটি স্ক্রিনশট থাকবে যেখানে চারটি রিকোয়েস্ট দেখানো আছে)

🔍 প্রথম রিকোয়েস্ট: HTML ডকুমেন্ট

প্রথম রিকোয়েস্টের type হলো document, অর্থাৎ এটি HTML ফাইল। এই HTML দেখতে কিছুটা এইরকম:

(স্ক্রিনশটে HTML কোড)

কিন্তু... যখন আমরা পেজের HTML কোড দেখি, আমরা লক্ষ্য করি যে নোটগুলোর তালিকা (notes list) সেখানে নেই। HTML-এর <head> সেকশনে একটি <script> ট্যাগ আছে, যেটি main.js নামের একটি জাভাস্ক্রিপ্ট ফাইল লোড করতে ব্রাউজারকে বলে।

📜 JavaScript কোড (main.js ফাইলে)
var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    const data = JSON.parse(this.responseText)
    console.log(data)

    var ul = document.createElement('ul')
    ul.setAttribute('class', 'notes')

    data.forEach(function(note) {
      var li = document.createElement('li')

      ul.appendChild(li)
      li.appendChild(document.createTextNode(note.content))
    })

    document.getElementById('notes').appendChild(ul)
  }
}

xhttp.open('GET', '/data.json', true)
xhttp.send()


✅ এখন কোড বোঝা জরুরি নয় — কোডটা শুধু উদাহরণ হিসেবে দেখানো হয়েছে। আপনি পার্ট ১ থেকে কোডিং শুরু করবেন। এই অংশের কোড কোর্সের মূল স্টাইল অনুসরণ করে না।

❓ fetch না ব্যবহার করে XMLHttpRequest কেন?

এখানে fetch() এর পরিবর্তে XMLHttpRequest ব্যবহার করা হয়েছে যাতে promises নিয়ে আলোচনা না করতে হয়। কোর্সের দ্বিতীয় অংশে আমরা fetch ও আধুনিক পদ্ধতিতে ফিরে আসব।

⚙️ ব্রাউজার কী করে?

JavaScript ফাইল লোড হওয়ার সাথে সাথেই ব্রাউজার কোড চালানো শুরু করে। শেষের এই দুটি লাইনে ব্রাউজার /data.json ঠিকানায় HTTP GET রিকোয়েস্ট পাঠায়:

xhttp.open('GET', '/data.json', true)
xhttp.send()


এই রিকোয়েস্টটি Network tab-এর নিচের দিকে থাকা সর্বশেষ অনুরোধ।

🌐 ব্রাউজারে সরাসরি data.json খুলে দেখুন

এই ঠিকানায় যান:

🔗 https://studies.cs.helsinki.fi/exampleapp/data.json

এখানে আপনি "raw JSON data" দেখতে পাবেন — অর্থাৎ কাঁচা তথ্য, যেখানে প্রতিটি নোটের content ও date আছে।

⚠️ ডিফল্টভাবে Chrome বা Chromium ভিত্তিক ব্রাউজার JSON ডেটা ভালোভাবে দেখাতে পারে না। আপনি চাইলে JSONView নামের Chrome এক্সটেনশন ব্যবহার করে JSON ডেটা সুন্দরভাবে ফরম্যাট করে দেখতে পারেন।

🔁 JavaScript কী করে?

এই JavaScript কোডটি /data.json থেকে নোটের JSON ডেটা ডাউনলোড করে, এবং প্রতিটি নোটের content দিয়ে একটি bullet-point list তৈরি করে।

এই অংশটি কী করে?
const data = JSON.parse(this.responseText)
console.log(data)

var ul = document.createElement('ul')
ul.setAttribute('class', 'notes')

data.forEach(function(note) {
  var li = document.createElement('li')

  ul.appendChild(li)
  li.appendChild(document.createTextNode(note.content))
})

document.getElementById('notes').appendChild(ul)

ব্যাখ্যা:

JSON.parse() দিয়ে সার্ভার থেকে পাওয়া JSON ডেটাকে JavaScript অবজেক্টে রূপান্তর করা হয়।

একটি <ul> (unordered list) তৈরি করা হয়।

data.forEach() দিয়ে প্রতিটি নোটের জন্য একটি <li> তৈরি করা হয় এবং তার মধ্যে note.content বসানো হয়।

এই <ul>-টি DOM-এ id="notes" এর ভিতরে অ্যাড করা হয়।

শুধু note.content ব্যবহৃত হয়েছে

note.date বা অন্যান্য তথ্য এখানে দেখানো হয়নি — শুধুমাত্র কনটেন্টই লিস্টে দেখানো হয়।

👀 Console Tab-এ দেখুন

ডেভেলপার কনসোলের Console ট্যাব খুলুন।

console.log(data)


এই লাইনের কারণে আপনি কনসোলে JSON ডেটার পূর্ণ অবজেক্ট দেখতে পারবেন।

▶️ ত্রিভুজ আইকনে ক্লিক করলে ডেটা এক্সপ্যান্ড হবে, এবং আপনি প্রতিটি নোটের content ও date দেখতে পাবেন।

📌 সারাংশ

Notes পেজ লোড হলে HTML-এ নোট থাকে না।

JavaScript main.js লোড করে JSON ডেটা নেয় /data.json থেকে।

তারপর ডাইনামিকভাবে <ul><li>...</li></ul> তৈরি করে স্ক্রিনে দেখায়।

সমস্ত লজিক চলে ব্রাউজারেই (client-side) — এটা মডার্ন ওয়েব অ্যাপ্লিকেশনের বৈশিষ্ট্য।

Console tab এবং console.log() কোর্সে বারবার কাজে আসবে।

ইভেন্ট হ্যান্ডলার ও কলব্যাক ফাংশন (Event Handlers and Callback Functions)
🧐 শুরুতেই কিছু অদ্ভুত মনে হতে পারে...

নিচের কোডটা একটু অদ্ভুত দেখাতে পারে:

var xhttp = new XMLHttpRequest()

xhttp.onreadystatechange = function() {
  // সার্ভার থেকে পাওয়া রেসপন্স প্রসেস করার কোড
}

xhttp.open('GET', '/data.json', true)
xhttp.send()


প্রশ্ন হলো — সার্ভারে অনুরোধ (request) পাঠানো হচ্ছে শেষ লাইনে, কিন্তু রেসপন্স হ্যান্ডলিং-এর কোড উপরের দিকে কেন?

📌 কী হচ্ছে এখানে?

এই লাইনে:

xhttp.onreadystatechange = function () {
  // ...
}


আমরা একটি ইভেন্ট হ্যান্ডলার সেট করছি, যা তখন চালু হবে যখন xhttp অবজেক্টের অবস্থা পরিবর্তন (state change) হবে।

👉 অর্থাৎ, যখন সার্ভার থেকে উত্তর (response) আসবে বা রিকোয়েস্ট প্রসেস হবে, তখন এই ফাংশন চালু হবে।

🔄 কীভাবে কাজ করে?
xhttp.onreadystatechange = function() {
  if (this.readyState == 4 && this.status == 200) {
    // সার্ভার রেসপন্স সফলভাবে এসেছে, এখন প্রসেস করো
  }
}


readyState == 4: এটি বোঝায় যে অনুরোধটি সম্পূর্ণ হয়েছে।

status == 200: HTTP স্ট্যাটাস ২০০ মানে সবকিছু ঠিক আছে (OK)।

এই দুটি শর্ত মিললে আমরা সার্ভার থেকে পাওয়া ডেটা প্রসেস করি।

🎯 Callback Function বলতে কী বোঝায়?

এই function() যা onreadystatechange ইভেন্টের জন্য সেট করা হয়েছে, তাকে callback function বলা হয়।

👉 কলব্যাক ফাংশন মানে এমন একটি ফাংশন, যা আপনি সরাসরি ডাকেন না — ব্রাউজার নিজেই নির্দিষ্ট ইভেন্ট ঘটলে ফাংশনটি চালায়।

⚙️ পুরো প্রসেস:

আপনি রিকোয়েস্ট পাঠানোর কোড লিখেন (open + send)

তার আগে আপনি বলে দেন: "যখন রেসপন্স আসবে, তখন এই ফাংশনটা চালাও"

এরপর ব্রাউজার নিজে দেখে কখন রেসপন্স এলো — তখন সে কলব্যাক ফাংশনটি চালিয়ে দেয়।

✅ এই ধারণাটি জাভাস্ক্রিপ্টে খুব সাধারণ

এই ধরণের ইভেন্ট চালিত (event-driven) প্রোগ্রামিং JavaScript-এ খুবই পরিচিত ও গুরুত্বপূর্ণ:

উদাহরণ:

একটা বাটনে ক্লিক করলে কাজ করা

টাইপ করলে লাইভ সাজেশন দেখানো

স্ক্রল করলে নতুন কনটেন্ট লোড হওয়া

সবক্ষেত্রেই কলব্যাক ফাংশন ব্যবহার হয়।

🧠 সারাংশ
বিষয়	ব্যাখ্যা
onreadystatechange	ইভেন্ট, যা HTTP রিকোয়েস্টের স্টেট পরিবর্তন হলে ঘটে
function()	একটি callback function — এটি ইভেন্ট ঘটলে ব্রাউজার নিজে চালায়
readyState == 4	রিকোয়েস্ট সম্পূর্ণ হয়েছে
status == 200	রেসপন্স সফল (OK)
কে চালায়?	আপনি নন — ব্রাউজার চালায় (runtime environment)

📌 Callback function এবং event-driven ধারণাগুলো JavaScript-এর সবচেয়ে গুরুত্বপূর্ণ বিষয়গুলোর মধ্যে একটি। আপনি কোর্সে যত এগোবেন, এটি তত বেশি কাজে আসবে।
